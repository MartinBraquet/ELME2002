#include "triangulation_gr3.h"
#include "../path/path_planning_gr3.h"
#include "../useful/limit_angle_gr3.cc"
#include "init_pos_gr3.h"
#include <math.h>
#include <stdio.h>

#define PRINT_TRIANGULATION 1

#if ROBOTICS_COURSE
    NAMESPACE_INIT(ctrlGr3);
#endif

int cmp(const void *x, const void *y)
{
  double xx = *(double*)x, yy = *(double*)y;
  if (xx < yy) return -1;
  if (xx > yy) return  1;
  return 0;
}

/*! \brief finds the position thanks to the beacons
 * 
 * \param[in,out] cvs controller main structure
 */
void triangulation(CtrlStruct *cvs)
{
    RobotPosition *rob_pos = cvs->rob_pos;
    PathPlanning *path = cvs->path;
    
    CtrlIn *inputs = cvs->inputs;
    int i;
    
    if (PRINT_TRIANGULATION) {
        printf("last_rising_fixed : ");
        for (i=0; i<NB_STORE_EDGE; i++) {
            printf("%1.3f   ", inputs->last_rising_fixed[i] * 180 / M_PI);
        }
        
        printf("\nlast_falling_fixed: ");
        for (i=0; i<NB_STORE_EDGE; i++) {
            printf("%1.3f   ", inputs->last_falling_fixed[i] * 180 / M_PI);
        }
        
        printf("\nnb_rising_fixed: %d\n", inputs->nb_rising_fixed);
        printf("nb_rising_fixed: %d\n", inputs->nb_falling_fixed);
        printf("rising_index_fixed: %d\n", inputs->rising_index_fixed);
        printf("falling_index_fixed: %d\n", inputs->falling_index_fixed);
    }
    
    double theta_beacon[3];
    for (i=0; i<3; i++) {
        theta_beacon[i] = cvs->rob_pos->theta;
    }
    
    /*
    int index0_falling[4] = {0, 3, 6, 9};
    int index0_rising[4] = {0, 3, 6, 9};
    int index1_falling[3] = {1, 4, 7};
    int index1_rising[3] = {1, 4, 7};
    int index2_falling[3] = {2, 5, 8};
    int index2_rising[3] = {2, 5, 8};
    
    
    for (i=0; i<4; i++) {
        index0_falling[i] = (index0_falling[i] + inputs->falling_index_fixed + 1) % NB_STORE_EDGE;
        index0_rising[i]  = (index0_rising[i]  + inputs->rising_index_fixed + 1) % NB_STORE_EDGE;
        theta_beacon[0] += (inputs->last_rising_fixed[index0_rising[i]] + inputs->last_falling_fixed[index0_falling[i]]) / 2.0 / 4.0;
    }
   
    for (i=0; i<3; i++) {
        index1_falling[i] = (index1_falling[i] + inputs->falling_index_fixed + 1) % NB_STORE_EDGE;
        index1_rising[i]  = (index1_rising[i]  + inputs->rising_index_fixed + 1) % NB_STORE_EDGE;
        theta_beacon[1] += (inputs->last_rising_fixed[index1_rising[i]] + inputs->last_falling_fixed[index1_falling[i]]) / 2.0 / 3.0;
        
        index2_falling[i] = (index2_falling[i] + inputs->falling_index_fixed + 1) % NB_STORE_EDGE;
        index2_rising[i]  = (index2_rising[i]  + inputs->rising_index_fixed + 1) % NB_STORE_EDGE;
        theta_beacon[2] += (inputs->last_rising_fixed[index2_rising[i]] + inputs->last_falling_fixed[index2_falling[i]]) / 2.0 / 3.0;
    }
    
    if (PRINT_TRIANGULATION) {
        printf("index0_falling: ");
        for (i=0; i<4; i++) {
            printf("%d  ", index0_falling[i]);
        }
        printf("\nindex0_rising: ");
        for (i=0; i<4; i++) {
            printf("%d  ", index0_rising[i]);
        }
        
       printf("\nindex1_falling: ");
        for (i=0; i<3; i++) {
            printf("%d  ", index1_falling[i]);
        }
        printf("\nindex1_rising: ");
        for (i=0; i<3; i++) {
            printf("%d  ", index1_rising[i]);
        }
        
       printf("\nindex2_falling: ");
        for (i=0; i<3; i++) {
            printf("%d  ", index2_falling[i]);
        }
        printf("\nindex2_rising: ");
        for (i=0; i<3; i++) {
            printf("%d  ", index2_rising[i]);
        }
        
        
        printf("\nlast_falling_fixed 0: ");
        for (i=0; i<4; i++) {
            printf("%1.3f  ", inputs->last_falling_fixed[index0_falling[i]] * 180 / M_PI);
        }
        printf("\nlast_rising_fixed 0: ");
        for (i=0; i<4; i++) {
            printf("%1.3f  ", inputs->last_rising_fixed[index0_rising[i]] * 180 / M_PI);
        }
        
        printf("\nlast_falling_fixed 1: ");
        for (i=0; i<3; i++) {
            printf("%1.3f  ", inputs->last_falling_fixed[index1_falling[i]] * 180 / M_PI);
        }
        printf("\nlast_rising_fixed 1: ");
        for (i=0; i<3; i++) {
            printf("%1.3f  ", inputs->last_rising_fixed[index1_rising[i]] * 180 / M_PI);
        }
        
        printf("\nlast_falling_fixed 2: ");
        for (i=0; i<3; i++) {
            printf("%1.3f  ", inputs->last_falling_fixed[index2_falling[i]] * 180 / M_PI);
        }
        printf("\nlast_rising_fixed 2: ");
        for (i=0; i<3; i++) {
            printf("%1.3f  ", inputs->last_rising_fixed[index2_rising[i]] * 180 / M_PI);
        }
    }
    */
    
    int last_edge[3] = {2, 0, 1};
    double angle_rising, angle_falling; 
    
    for (i=0; i<3; i++) {
        if (inputs->falling_index_fixed == inputs->rising_index_fixed) {
            angle_rising = inputs->last_rising_fixed[(inputs->rising_index_fixed - i + NB_STORE_EDGE) % NB_STORE_EDGE];
            angle_falling = inputs->last_falling_fixed[(inputs->falling_index_fixed - i + NB_STORE_EDGE) % NB_STORE_EDGE];
        } else {
            theta_beacon[i] += (inputs->last_rising_fixed[(inputs->rising_index_fixed - i + NB_STORE_EDGE) % NB_STORE_EDGE] 
                          + inputs->last_falling_fixed[(inputs->falling_index_fixed - last_edge[i] + NB_STORE_EDGE) % NB_STORE_EDGE]) / 2.0;
        }
        if (angle_rising - angle_falling > M_PI) {
            angle_falling += 2 * M_PI;
        }
        theta_beacon[i] += (angle_rising + angle_falling) / 2.0;
        limit_angle(&theta_beacon[i]);
        
        /*
        if (abs(angle_rising - angle_falling) > 1.0) {
            printf("Error angle: %1.3f   %1.3f   theta = %1.3f\n", angle_rising * 180 / M_PI, angle_falling * 180 / M_PI, theta_beacon[i] * 180 / M_PI);
        }
        */
    }
    
    qsort(theta_beacon, sizeof(theta_beacon)/sizeof(theta_beacon[0]), sizeof(theta_beacon[0]), cmp);
    
    if (PRINT_TRIANGULATION) {printf("\ntheta0: %1.3f            ; theta1: %1.3f               ; theta2: %1.3f\n", theta_beacon[0] * 180/M_PI, theta_beacon[1] * 180/M_PI, theta_beacon[2] * 180/M_PI);}
    
    // Source: http://www.telecom.ulg.ac.be/publi/publications/pierlot/Pierlot2014ANewThree/
    
    double x1_p = path->beacons[0][0] - path->beacons[0][1];
    double y1_p = path->beacons[1][0] - path->beacons[1][1];
    double x3_p = path->beacons[0][2] - path->beacons[0][1];
    double y3_p = path->beacons[1][2] - path->beacons[1][1];
    
    double T12 = 1.0 / tan(theta_beacon[1] - theta_beacon[0]);
    double T23 = 1.0 / tan(theta_beacon[2] - theta_beacon[1]);
    double T31 = (1.0 - T12 * T23) / (T12 + T23);
    
    double x12_p = x1_p + T12 * y1_p;
    double y12_p = y1_p - T12 * x1_p;
    double x23_p = x3_p - T23 * y3_p;
    double y23_p = y3_p + T23 * x3_p;
    double x31_p = (x3_p + x1_p) + T31 * (y3_p - y1_p);
    double y31_p = (y3_p + y1_p) - T31 * (x3_p - x1_p);
    
    double k31_p = x1_p * x3_p + y1_p * y3_p + T31 * (x1_p * y3_p - x3_p * y1_p);
    
    double D = (x12_p - x23_p) * (y23_p - y31_p) - (y12_p - y23_p) * (x23_p - x31_p);
    
    // printf("TRIANGULATION: D = %f", D);
    
    if (fabs(D) > 1e-6) {
        rob_pos->x_beacons = path->beacons[0][1] + k31_p * (y12_p - y23_p) / D;
        rob_pos->y_beacons = path->beacons[1][1] + k31_p * (x23_p - x12_p) / D;
        rob_pos->theta_beacons = atan2(path->beacons[1][0] - rob_pos->y_beacons, path->beacons[0][0] - rob_pos->x_beacons) - (theta_beacon[0] - cvs->rob_pos->theta);
    } else {
        printf("TRIANGULATION: D = 0 !\n");
    }
}

/*! \brief finds the x position at the end of calibration (TO FIX)
 * 
 * \param[in,out] cvs controller main structure
 */
double calib_find_x(CtrlStruct *cvs)
{
    CtrlIn *inputs = cvs->inputs;
    int i;
    
    printf("last_rising_fixed : ");
    for (i=0; i<NB_STORE_EDGE; i++) {
        printf("%1.3f   ", inputs->last_rising_fixed[i] * 180 / M_PI);
    }
    
    printf("\nlast_falling_fixed: ");
    for (i=0; i<NB_STORE_EDGE; i++) {
        printf("%1.3f   ", inputs->last_falling_fixed[i] * 180 / M_PI);
    }
    
    printf("\nnb_rising_fixed: %d\n", inputs->nb_rising_fixed);
    printf("nb_rising_fixed: %d\n", inputs->nb_falling_fixed);
    printf("rising_index_fixed: %d\n", inputs->rising_index_fixed);
    printf("falling_index_fixed: %d\n", inputs->falling_index_fixed);
    
    int index1_falling[4] = {0, 3, 6, 9};
    int index1_rising[4] = {0, 3, 6, 9};
    int index2_falling[3] = {1, 4, 7};
    int index2_rising[3] = {1, 4, 7};
    int index3_falling[3] = {2, 5, 8};
    int index3_rising[3] = {2, 5, 8};
    
    double theta_beacon[3];
    for (i=0; i<3; i++) {
        theta_beacon[i] = cvs->rob_pos->theta;
    }
    
    printf("index1_falling: ");
    for (i=0; i<4; i++) {
        index1_falling[i] = (index1_falling[i] + inputs->falling_index_fixed + 1) % NB_STORE_EDGE;
        index1_rising[i]  = (index1_rising[i]  + inputs->rising_index_fixed + 1) % NB_STORE_EDGE;
        theta_beacon[0] += (inputs->last_rising_fixed[index1_rising[i]] + inputs->last_falling_fixed[index1_falling[i]]) / 2.0 / 4.0;
        printf("%d  ", index1_falling[i]);
    }
   
    printf("\nindex2_falling: ");
    for (i=0; i<3; i++) {
        index2_falling[i] = (index2_falling[i] + inputs->falling_index_fixed + 1) % NB_STORE_EDGE;
        index2_rising[i]  = (index2_rising[i]  + inputs->rising_index_fixed + 1) % NB_STORE_EDGE;
        theta_beacon[1] += (inputs->last_rising_fixed[index2_rising[i]] + inputs->last_falling_fixed[index2_falling[i]]) / 2.0 / 3.0;
        printf("%d   ", index2_falling[i]);
        
        index3_falling[i] = (index3_falling[i] + inputs->falling_index_fixed + 1) % NB_STORE_EDGE;
        index3_rising[i]  = (index3_rising[i]  + inputs->rising_index_fixed + 1) % NB_STORE_EDGE;
        theta_beacon[2] += (inputs->last_rising_fixed[index3_rising[i]] + inputs->last_falling_fixed[index3_falling[i]]) / 2.0 / 3.0;
    }
     
    for (i=0; i<3; i++) {
        limit_angle(&theta_beacon[i]);
    }
    
    qsort(theta_beacon, sizeof(theta_beacon)/sizeof(theta_beacon[0]), sizeof(theta_beacon[0]), cmp);
    
    printf("\ntheta1: %1.3f ; theta2: %1.3f ; theta3: %1.3f\n", theta_beacon[0] * 180/M_PI, theta_beacon[1] * 180/M_PI, theta_beacon[2] * 180/M_PI);
   
    double x1 = cvs->path->beacons[0][1] - fabs(cvs->rob_pos->y - cvs->path->beacons[1][1]) * tan(M_PI / 2.0 - theta_beacon[1]);
    double x2 = cvs->path->beacons[0][2] - fabs(cvs->rob_pos->y - cvs->path->beacons[1][2]) * tan(M_PI / 2.0 - theta_beacon[2]);
    
    // printf("x1: %1.3f ; x2: %1.3f     %1.3f    %1.3f   %1.3f \n", x1, x2, abs(cvs->rob_pos->y - cvs->path->beacons_y[1]) * tan(M_PI / 2.0 - theta_beacon[1]), abs(cvs->rob_pos->y - cvs->path->beacons_y[2]) * tan(M_PI / 2.0 - theta_beacon[2]));
    
    return (x1 + x2) / 2.0;
}

#if ROBOTICS_COURSE
    NAMESPACE_CLOSE();
#endif
